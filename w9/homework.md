# Домашнее задание по неделе 9
Число в скобках - количество баллов.
_ДЗ частично взято с [соответствующей лабы](http://cs.mipt.ru/advanced_python/lessons/lab09.html)_

## Итераторы, итерируемые объекты
1. (2) Реализуйте класс `BinTree` двоичного дерева, итерирование по которму происходит в порядке обхода в глубину.
2. (3) Скачайте архив, и положите его в папку с неделей 9.
Создаейте класс `TextLoader`, который принимает в инициализаторе адрес архива.
Затем добейтесь от класса следующего поведения:
    - При инициализации объекта (т.е. в методе `__init__`) этот класс должен разархивировать архив в какую-либо папку (имя неважно);
    - Метод `__len__` должен возвращать количество текстов в папке;
    - Метод `__next__`, который позволяет итерироваться по распакованным текстам, должен возвращать объект файла (тот, что возвращает `open()`);
    - При итерировании возвращаются нормализованные тексты, т.е. приводятся к нижнему регистру и убираются знаки препинания.

Обратите внимание, что метод `__len__` не должен считывать все файлы.
Также нельзя читать все файлы за раз - нужно это делать по мере необходимости.

## Coroutines
3. (2) От некоторого устройства в режиме реального времени приходят данные.
Необходимо написать сопрограмму, которая вычисляет среднее, дисперсию, а также количество элементов в переданном наборе данных с устройства.
Результаты работы сопрограмма должна выдавать при отправке соответствующих сигналов.
4. (4) Представьте, что у вас настроено взаимодействие с сервером, от которого приходят пакеты, содержащие сообщения от различных клиентов. Обработка каждого из клиентов должна идти в отдельном потоке.
Реализуйте:
    1. Корутину `connect_user`, которая принимает данные авторизации от пользователя, открывает файл с расширением .txt и создает на его основе корутину `write_to_file`.
    2. Корутину `write_to_file(f_obj)`, которая записывает переданное планировщиком задач сообщение пользователя в файловый объект, переданный в качестве аргумента при генерации. 
    Также корутина принимает и обрабатывает сигнал об окончании соединения и выходит из сопрограммы.
    3. Планировщик задач, распределяющий задачи по сопроцессам на каждого пользователя.

## Бонус (оцениваемый)
За выполнение этих задач вы можете получить баллы сверх нормы.

1. (3) Напишите тесты на каждую вашу программу, используя `pytest`.
Используйте везде, где возможно, фикстуры.
