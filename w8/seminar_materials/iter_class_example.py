class ChaosGenerator:
    """
    Генератор хаоса
    """

    def __init__(self, x0, k, first_n):
        self.current, self.k = x0, k
        self.n = first_n

    # __iter__(self) - это специальный метод
    # Он вызывается, когда нужно "подготовиться" к итерированию. 
    # Он должен возвращать итератор - объект, который реализует внутри себя метод __next__()
    # Поскольку в этом классе реализован метод __next__() ниже, мы просто вернем self
    def __iter__(self):
        return self

    # Вообще, метод __iter__() также вызовется, если написать:
    # iter(ChaosGenerator(1.01, 1.1, 10))
    # и он вернет объект итератора (в данном случае сам экземпляр класса)

    def __next__(self):
        """
        __next__(self) - это специальный метод.
        Он вызывается каждый раз, когда нужно получить следующий объект.
        Обратите внимание, что по договоренности мы должны выбрасывать StopIteration() как сигнал окончания генератора (того, что больше ничего не будет генерироваться)
        """
        if self.n == 0:
            raise StopIteration()
        # Вернем то, что сейчас лежит в current
        to_return = self.current
        # А затем обновим self.current,
        # чтобы при следующем вызове вернуть уже другое значение

        self.current = self.k * self.current * (1 - self.current)

        self.n -= 1
        # Обратите внимание, что нужно вызывать return, а не yeild
        return to_return


if __name__ == "__main__":
    # For-like iteration
    for i in ChaosGenerator(x0=0.8, k=3.9, first_n=1000):
        print(i)
    # Если интересно, почему результаты такие разные, советую почитать https://ru.wikipedia.org/wiki/Логистическое_отображение

